<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Androp â€” P2P Share</title>

<!-- Apple-like font fallback -->
<style>
  :root{
    --glass-bg: rgba(255,255,255,0.06);
    --accent: #00e6c3;
    --muted: rgba(255,255,255,0.7);
    --glass-border: rgba(255,255,255,0.08);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial;color:#fff;background:
    radial-gradient(1200px 600px at 10% 10%, rgba(0,200,150,0.05), transparent 10%),
    linear-gradient(180deg,#071426 0%, #0b1220 100%);
    -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;
  }
  .app {
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:18px;
  }

  .card {
    width:100%;
    max-width:420px;
    border-radius:18px;
    background: var(--glass-bg);
    backdrop-filter: blur(10px) saturate(120%);
    -webkit-backdrop-filter: blur(10px) saturate(120%);
    border: 1px solid var(--glass-border);
    box-shadow: 0 8px 30px rgba(2,6,23,0.6);
    padding:18px;
  }

  .top {
    display:flex;
    gap:12px;
    align-items:center;
  }
  .logo {
    width:64px;height:64px;border-radius:14px;object-fit:cover;border:1px solid rgba(255,255,255,0.06);
    box-shadow: 0 6px 18px rgba(0,0,0,0.45);
  }
  h1{font-size:20px;margin:0}
  p.muted{margin:4px 0 8px;color:var(--muted);font-size:13px}

  .profile {
    display:flex;gap:8px;align-items:center;margin-top:12px;
  }
  .emoji {
    width:56px;height:56px;border-radius:12px;border:1px solid rgba(255,255,255,0.06);
    display:flex;align-items:center;justify-content:center;font-size:28px;background:rgba(255,255,255,0.02);
  }
  input[type="text"],select{
    flex:1;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);
    background:transparent;color:inherit;font-size:15px;
  }

  .btn {
    display:block;width:100%;padding:14px;border-radius:14px;border:none;background:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
    color:#fff;font-size:16px;cursor:pointer;margin-top:12px;box-shadow:0 8px 20px rgba(2,6,23,0.6);
  }
  .btn:active{transform:scale(0.99)}

  .tiny {font-size:13px;color:var(--muted);margin-top:8px}

  /* modal overlay */
  .overlay {
    position:fixed;inset:0;background:rgba(2,6,23,0.5);display:flex;align-items:center;justify-content:center;
    z-index:1200;padding:18px;
  }
  .dialog {
    width:100%;max-width:420px;border-radius:16px;padding:14px;background:var(--glass-bg);
    border:1px solid var(--glass-border);backdrop-filter:blur(8px);
  }
  .row{display:flex;gap:8px}
  .small {padding:10px;border-radius:10px;border:none;flex:1;cursor:pointer;background:rgba(255,255,255,0.03);}

  /* camera preview */
  #cameraPreview{width:100%;height:320px;background:#000;border-radius:10px;object-fit:cover;}

  /* qr box */
  #qrBox{display:flex;justify-content:center;padding:12px}

  /* chat area */
  .chat {
    margin-top:12px;border-radius:12px;padding:10px;background:rgba(0,0,0,0.08);max-height:220px;overflow:auto;
  }
  .chat .me{color:var(--accent);font-weight:600}
  .chat .peer{color:#fff}

  /* file list */
  .files {margin-top:8px;display:flex;flex-direction:column;gap:8px}
  .fileItem{background:rgba(255,255,255,0.02);padding:10px;border-radius:10px;font-size:14px}

  /* ripple */
  .ripple {
    position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:80px;height:80px;border-radius:50%;pointer-events:none;
    background:radial-gradient(circle, rgba(0,230,180,0.3), transparent 60%);z-index:1400;animation:rippleAnim 900ms ease-out;
  }
  @keyframes rippleAnim{
    from{transform:translate(-50%,-50%) scale(0.5);opacity:0.9}
    to{transform:translate(-50%,-50%) scale(4);opacity:0}
  }

  /* history */
  .history{margin-top:12px;display:flex;flex-direction:column;gap:8px}
  .histItem{display:flex;align-items:center;gap:10px;padding:8px;border-radius:10px;background:rgba(255,255,255,0.02)}
  .histEmoji{width:40px;height:40px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:20px}

  /* responsive */
  @media (max-width:420px){ .card{padding:14px} }
</style>

<!-- QR generator and jsQR (for scanning) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jsqr/dist/jsQR.min.js"></script>

</head>
<body>
<div class="app">
  <div class="card" role="main" aria-labelledby="title">
    <div class="top">
      <img class="logo" src="https://i.ibb.co/h1XB0F9D/Chat-GPT-Image-Sep-16-2025-10-29-13-PM.png" alt="Androp logo">
      <div>
        <h1 id="title">Androp</h1>
        <p class="muted">Quickly connect & share â€” tap Connect</p>
      </div>
    </div>

    <div class="profile">
      <div class="emoji" id="emojiPreview">ðŸ™‚</div>
      <input id="nameInput" type="text" placeholder="Your name (e.g. Alice)">
      <input id="emojiInput" type="text" maxlength="2" style="width:60px;text-align:center" aria-label="emoji">
    </div>

    <button class="btn" id="connectBtn">Connect device</button>

    <div class="tiny">Quick history</div>
    <div class="history" id="historyList"></div>

    <div class="tiny">Chat & files</div>
    <div class="chat" id="chatLog"></div>

    <div class="files" id="fileList"></div>

  </div>
</div>

<!-- Modals (hidden by default) -->
<div id="connectModal" class="overlay" style="display:none">
  <div class="dialog">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <strong>Connect</strong>
      <button id="closeConnect" style="background:none;border:none;color:var(--muted);cursor:pointer">âœ•</button>
    </div>
    <p class="tiny">Choose how to connect</p>
    <div class="row" style="margin-top:8px">
      <button class="small" id="hostRole">Host (scan)</button>
      <button class="small" id="recvRole">Receiver (show QR)</button>
    </div>
  </div>
</div>

<div id="cameraModal" class="overlay" style="display:none">
  <div class="dialog">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <strong>Scan QR</strong>
      <button id="closeCamera" style="background:none;border:none;color:var(--muted);cursor:pointer">âœ•</button>
    </div>
    <video id="cameraPreview" autoplay playsinline></video>
    <p class="tiny">Point camera at the partner's QR</p>
  </div>
</div>

<div id="qrModal" class="overlay" style="display:none">
  <div class="dialog">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <strong>Your QR</strong>
      <button id="closeQR" style="background:none;border:none;color:var(--muted);cursor:pointer">âœ•</button>
    </div>
    <div id="qrBox"></div>
    <p class="tiny">Have the other device scan this QR</p>
  </div>
</div>

<!-- firebase module + app logic -->
<script type="module">
/* ---------------------------
  Firebase imports and init
   (you provided the firebaseConfig; using it as-is)
   Make sure RTDB rules allow these paths or enable auth.
----------------------------*/
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js";
import { getDatabase, ref, set, push, onChildAdded, onValue, remove, off, update, get, child } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyCCAdWENmFuXfruVUywVHlQi4NJdbwRwSw",
  authDomain: "drop-48e1c.firebaseapp.com",
  projectId: "drop-48e1c",
  storageBucket: "drop-48e1c.firebasestorage.app",
  messagingSenderId: "1038653970015",
  appId: "1:1038653970015:web:4ecb0891a794c40758edea",
  measurementId: "G-MEF6129M9T"
};
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
// Realtime DB base path used here
// e.g., rooms/<roomId> will hold offer/answer/candidates and profiles

/* ---------------------------
  UI references
----------------------------*/
const nameInput = document.getElementById('nameInput');
const emojiInput = document.getElementById('emojiInput');
const emojiPreview = document.getElementById('emojiPreview');
const connectBtn = document.getElementById('connectBtn');
const connectModal = document.getElementById('connectModal');
const hostRole = document.getElementById('hostRole');
const recvRole = document.getElementById('recvRole');
const closeConnect = document.getElementById('closeConnect');

const cameraModal = document.getElementById('cameraModal');
const cameraPreview = document.getElementById('cameraPreview');
const closeCamera = document.getElementById('closeCamera');

const qrModal = document.getElementById('qrModal');
const qrBox = document.getElementById('qrBox');
const closeQR = document.getElementById('closeQR');

const chatLog = document.getElementById('chatLog');
const fileList = document.getElementById('fileList');
const historyList = document.getElementById('historyList');

/* ---------------------------
  Local user identity
----------------------------*/
let myUid = localStorage.getItem('androp_uid');
if (!myUid) {
  myUid = 'u_' + Math.random().toString(36).slice(2,10);
  localStorage.setItem('androp_uid', myUid);
}
nameInput.value = localStorage.getItem('androp_name') || '';
emojiInput.value = localStorage.getItem('androp_emoji') || 'ðŸ™‚';
emojiPreview.textContent = emojiInput.value;

/* save profile on change */
nameInput.addEventListener('input', ()=>localStorage.setItem('androp_name', nameInput.value));
emojiInput.addEventListener('input', ()=>{
  localStorage.setItem('androp_emoji', emojiInput.value);
  emojiPreview.textContent = emojiInput.value || 'ðŸ™‚';
});

/* ---------------------------
  Small utilities
----------------------------*/
function el(tag, cls){ const d=document.createElement(tag); if(cls) d.className=cls; return d; }
function show(elm){ elm.style.display='flex'; }
function hide(elm){ elm.style.display='none'; }
function ripple(){ const r=document.createElement('div'); r.className='ripple'; document.body.appendChild(r); setTimeout(()=>r.remove(),900); }

/* chat logging */
function log(text, who='peer'){ const d = el('div'); d.textContent = text; d.className = who==='me'? 'me': 'peer'; chatLog.appendChild(d); chatLog.scrollTop = chatLog.scrollHeight; }

/* history UI */
function renderHistory(){
  const raw = JSON.parse(localStorage.getItem('androp_history') || '[]');
  historyList.innerHTML = '';
  raw.slice().reverse().forEach(h=>{
    const item = el('div','histItem');
    const em = el('div','histEmoji'); em.textContent = h.emoji || 'ðŸ™‚';
    const name = el('div'); name.innerHTML = `<strong>${h.name}</strong><div class="tiny" style="color:var(--muted)">${new Date(h.t).toLocaleString()}</div>`;
    item.appendChild(em); item.appendChild(name);
    historyList.appendChild(item);
  });
}
function addHistory(obj){
  const curr = JSON.parse(localStorage.getItem('androp_history') || '[]');
  // keep unique by uid
  const exists = curr.find(c=>c.uid === obj.uid);
  if(!exists) curr.push(obj); else { exists.t = Date.now(); }
  // limit to 30
  if(curr.length>30) curr.splice(0,curr.length-30);
  localStorage.setItem('androp_history', JSON.stringify(curr));
  renderHistory();
}

/* initial render */
renderHistory();

/* ---------------------------
  WebRTC & Signaling (RTDB)
----------------------------*/
const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

let pc = null;
let dc = null;
let roomRef = null;
let localCandidatesRef = null;
let remoteCandidatesRef = null;
let roomIdGlobal = null;

/* create room (receiver): make offer, write offer + profile, show QR with roomId */
async function createRoomAndShowQR(){
  // create room id short
  const roomId = Math.random().toString(36).slice(2,9);
  roomIdGlobal = roomId;
  pc = new RTCPeerConnection(configuration);

  // data channel for file/chat (receiver may accept channel via ondatachannel)
  pc.ondatachannel = (e)=>{
    dc = e.channel;
    setupDataChannel(dc);
  };

  // collect local candidates and write them to RTDB under rooms/<roomId>/calleeCandidates
  localCandidatesRef = ref(db, `rooms/${roomId}/calleeCandidates`);
  remoteCandidatesRef = ref(db, `rooms/${roomId}/callerCandidates`);
  pc.onicecandidate = (event) => {
    if(event.candidate){
      const cRef = push(localCandidatesRef);
      set(cRef, event.candidate.toJSON());
    }
  };

  // create offer
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);

  // wait briefly for ICE to gather (simple approach)
  await new Promise(res => setTimeout(res, 1500));

  // write offer + profile to RTDB
  const roomRefBase = ref(db, `rooms/${roomId}`);
  const profile = { uid: myUid, name: nameInput.value || 'anon', emoji: emojiInput.value || 'ðŸ™‚', t: Date.now() };
  await set(roomRefBase, { offer: pc.localDescription.toJSON(), receiverProfile: profile });

  // listen for answer
  onValue(ref(db, `rooms/${roomId}/answer`), async snapshot=>{
    const ans = snapshot.val();
    if(ans && ans.sdp){
      const remoteDesc = { type: ans.type || 'answer', sdp: ans.sdp };
      await pc.setRemoteDescription(remoteDesc);
      ripple(); // connected animation (will also trigger datachannel onopen)
      // once connected, attach candidate listeners
      // listen for caller candidates (host side)
      onChildAdded(remoteCandidatesRef, snapshot=>{
        const c = snapshot.val();
        if(c) pc.addIceCandidate(c).catch(()=>{});
      });
    }
  });

  // show QR (contain roomId and receiver's profile)
  const payload = { roomId, profile };
  qrBox.innerHTML = '';
  new QRCode(qrBox, { text: JSON.stringify(payload), width: 220, height: 220 });
  show(qrModal);
}

/* Host: open camera, scan QR, fetch offer from DB, then create answer and write it */
let camStream = null;
let scanning = false;

async function startCameraAndScan(){
  try{
    camStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
    cameraPreview.srcObject = camStream;
    show(cameraModal);
    scanning = true;
    const video = cameraPreview;
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    async function frameLoop(){
      if(!scanning) return;
      if(video.videoWidth === 0 || video.videoHeight === 0){ requestAnimationFrame(frameLoop); return; }
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      ctx.drawImage(video,0,0,canvas.width,canvas.height);
      const imageData = ctx.getImageData(0,0,canvas.width,canvas.height);
      const code = jsQR(imageData.data, imageData.width, imageData.height, { inversionAttempts: 'attemptBoth' });
      if(code && code.data){
        // found QR payload
        scanning = false;
        stopCamera();
        hide(cameraModal);
        ripple();
        try{
          const payload = JSON.parse(code.data);
          await handleScannedPayload(payload);
        }catch(e){
          alert('Scanned QR invalid');
        }
        return;
      }
      requestAnimationFrame(frameLoop);
    }
    requestAnimationFrame(frameLoop);
  }catch(err){
    console.error('camera err',err);
    alert('Camera access denied or not available');
  }
}

function stopCamera(){
  if(camStream){
    camStream.getTracks().forEach(t=>t.stop());
    camStream = null;
  }
  scanning = false;
}

/* When host scans payload {roomId, profile}, join the room by fetching offer and writing answer/candidates */
async function handleScannedPayload(payload){
  if(!payload || !payload.roomId) return alert('Invalid QR payload');
  const roomId = payload.roomId;
  roomIdGlobal = roomId;

  // read offer from DB
  const roomRefBase = ref(db, `rooms/${roomId}`);
  const snap = await get(child(ref(db), `rooms/${roomId}`));
  const roomObj = snap.exists()? snap.val() : null;
  if(!roomObj || !roomObj.offer){
    return alert('Offer not found in DB â€” make sure the receiver created QR and wrote the offer.');
  }

  // create peer connection and data channel (host creates datachannel)
  pc = new RTCPeerConnection(configuration);
  dc = pc.createDataChannel('andropData');
  setupDataChannel(dc);

  // candidate refs
  localCandidatesRef = ref(db, `rooms/${roomId}/callerCandidates`);
  remoteCandidatesRef = ref(db, `rooms/${roomId}/calleeCandidates`);
  pc.onicecandidate = (event)=>{
    if(event.candidate){
      const cRef = push(localCandidatesRef);
      set(cRef, event.candidate.toJSON());
    }
  };

  // set remote offer
  const offer = roomObj.offer;
  await pc.setRemoteDescription({ type: offer.type || 'offer', sdp: offer.sdp });

  // create answer
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);

  // write answer to DB
  await set(ref(db, `rooms/${roomId}/answer`), pc.localDescription.toJSON());

  // listen for calleeCandidates (receiver side candidates)
  onChildAdded(remoteCandidatesRef, snapshot=>{
    const c = snapshot.val();
    if(c) pc.addIceCandidate(c).catch(()=>{});
  });

  // update that host connected to receiver: add to history locally
  const receiverProfile = payload.profile || { name:'unknown', emoji:'ðŸ™‚' };
  addHistory({ uid: receiverProfile.uid || ('r_'+roomId), name: receiverProfile.name, emoji: receiverProfile.emoji, t: Date.now() });

  // also write connection summary to DB under connections/<myUid> and connections/<peerUid>
  try{
    const myProfile = { uid: myUid, name: nameInput.value || 'anon', emoji: emojiInput.value || 'ðŸ™‚', t: Date.now() };
    await push(ref(db, `connections/${myUid}`), { peer: receiverProfile, at: Date.now(), roomId });
    await push(ref(db, `connections/${receiverProfile.uid||('r_'+roomId)}`), { peer: myProfile, at: Date.now(), roomId });
  }catch(e){ console.warn('write conn err', e); }
}

/* Setup DataChannel handlers for chat + file transfer */
let fileReceiver = null;
function setupDataChannel(channel){
  channel.onopen = ()=>{ logSystem('connected'); ripple(); };
  channel.onclose = ()=>{ logSystem('disconnected'); ripple(); };
  channel.onerror = (e)=>console.warn('dc err',e);
  channel.onmessage = (evt)=>{
    if(typeof evt.data === 'string'){
      try{
        const obj = JSON.parse(evt.data);
        if(obj.type === 'chat'){ logPeer(obj.text); }
        else if(obj.type === 'file-meta'){ // incoming file meta
          fileReceiver = { name: obj.name, size: obj.size, chunks: [], received: 0 };
          logSystem('incoming file: ' + obj.name);
        } else if(obj.type === 'file-end'){
          // assemble
          const blob = new Blob(fileReceiver.chunks);
          const url = URL.createObjectURL(blob);
          addReceivedFile(fileReceiver.name, url);
          fileReceiver = null;
        }
      }catch(e){
        // not json plain string
        logPeer(evt.data);
      }
    } else if (evt.data instanceof ArrayBuffer){
      if(fileReceiver){
        fileReceiver.chunks.push(evt.data);
        fileReceiver.received += evt.data.byteLength;
      }
    }
  };
}

/* chat helpers */
function logSystem(txt){ const d=el('div'); d.textContent = txt; d.style.opacity=0.8; d.style.fontSize='13px'; chatLog.appendChild(d); chatLog.scrollTop = chatLog.scrollHeight; }
function logPeer(txt){ const d=el('div'); d.textContent = txt; d.className='peer'; chatLog.appendChild(d); chatLog.scrollTop = chatLog.scrollHeight; }
function logMe(txt){ const d=el('div'); d.textContent = txt; d.className='me'; chatLog.appendChild(d); chatLog.scrollTop = chatLog.scrollHeight; }

/* UI events wiring */
connectBtn.addEventListener('click', ()=> show(connectModal));
closeConnect.addEventListener('click', ()=> hide(connectModal));

hostRole.addEventListener('click', async ()=>{
  hide(connectModal);
  // open camera to scan remote QR
  await startCameraAndScan();
});

recvRole.addEventListener('click', async ()=>{
  hide(connectModal);
  // create room and show QR with roomId + profile
  await createRoomAndShowQR();
  // push local history record (so receiver sees it locally)
  addHistory({ uid: myUid, name: nameInput.value||'anon', emoji: emojiInput.value||'ðŸ™‚', t: Date.now() });
});

closeCamera.addEventListener('click', ()=>{
  stopCamera();
  hide(cameraModal);
});

closeQR.addEventListener('click', ()=>{ hide(qrModal); /* optional: cleanup listeners if needed */ });

/* file sending UI via Web Share sheet or file picker (simple) */
fileList.addEventListener('click', ()=>{}); // placeholder for future

/* quick chat input via double-tap on card (simple) */
document.querySelector('.card').addEventListener('dblclick', async ()=>{
  const txt = prompt('Send quick message:');
  if(!txt || !dc || dc.readyState !== 'open') return alert('Not connected');
  dc.send(JSON.stringify({ type:'chat', text: txt }));
  logMe(txt);
});

/* Allow file sending via a simple file picker triggered by long press of connect button */
connectBtn.addEventListener('contextmenu', (e)=>{ e.preventDefault(); pickAndSendFile(); });

async function pickAndSendFile(){
  if(!dc || dc.readyState !== 'open') return alert('No active connection');
  const input = document.createElement('input'); input.type = 'file';
  input.onchange = async ()=> {
    const file = input.files[0];
    if(!file) return;
    // send meta first
    dc.send(JSON.stringify({ type:'file-meta', name: file.name, size: file.size }));
    // stream file in chunks
    const chunkSize = 64*1024;
    const reader = file.stream().getReader();
    while(true){
      const { done, value } = await reader.read();
      if(done) break;
      // value is Uint8Array
      // send as ArrayBuffer
      let offset = 0;
      while(offset < value.byteLength){
        const end = Math.min(offset + chunkSize, value.byteLength);
        const slice = value.slice(offset, end);
        dc.send(slice.buffer);
        offset = end;
        await new Promise(r=>setTimeout(r,10)); // yield occasionally
      }
    }
    // send end
    dc.send(JSON.stringify({ type:'file-end' }));
    logSystem('file sent: ' + file.name);
  };
  input.click();
}

/* add received file UI */
function addReceivedFile(name, url){
  const item = el('div','fileItem');
  item.innerHTML = `<strong>${name}</strong> â€” <a href="${url}" download="${name}" style="color:var(--accent)">Download</a>`;
  fileList.appendChild(item);
}

/* helper el */
function el(tag, cls){ const e=document.createElement(tag); if(cls) e.className = cls; return e; }

/* cleanup on page unload */
window.addEventListener('beforeunload', ()=> {
  try{ if(roomIdGlobal) remove(ref(db, `rooms/${roomIdGlobal}`)); }catch(e){}
});

/* small helper: get (v12) */
import { get as dbGet } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-database.js";

/* optional: listen for incoming room answer/candidates if we created room earlier (receiver) */
async function watchForAnswerCandidates(roomId){
  // for receiver we already set listener for /rooms/<roomId>/answer in createRoomAndShowQR
  // but we also watch for callerCandidates
  remoteCandidatesRef = ref(db, `rooms/${roomId}/callerCandidates`);
  onChildAdded(remoteCandidatesRef, snapshot=>{
    const c = snapshot.val();
    if(c && pc) pc.addIceCandidate(c).catch(()=>{});
  });
}

/* small polyfill for get(child(...)) usage earlier */
import { getDatabase as _getDatabase } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-database.js";

/* End of module */
</script>

</body>
</html>
