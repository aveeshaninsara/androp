<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>360 View + Accelerometer Control</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: sans-serif;
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        /* --- THE CUBE BUTTON CSS --- */
        .scene-container {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 60px;
            perspective: 400px;
            cursor: pointer;
            z-index: 100;
        }

        .cube {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            animation: spin 5s infinite linear;
            transition: transform 0.5s;
        }

        .cube-face {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 2px solid #00ffcc;
            background: rgba(0, 255, 204, 0.2);
            box-shadow: 0 0 10px #00ffcc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            font-weight: bold;
            text-transform: uppercase;
            user-select: none;
        }

        .face-front  { transform: rotateY(  0deg) translateZ(30px); }
        .face-right  { transform: rotateY( 90deg) translateZ(30px); }
        .face-back   { transform: rotateY(180deg) translateZ(30px); }
        .face-left   { transform: rotateY(-90deg) translateZ(30px); }
        .face-top    { transform: rotateX( 90deg) translateZ(30px); }
        .face-bottom { transform: rotateX(-90deg) translateZ(30px); }

        @keyframes spin {
            from { transform: rotateX(-20deg) rotateY(0deg); }
            to { transform: rotateX(-20deg) rotateY(360deg); }
        }

        .active-state .cube {
            animation: none;
            transform: rotateX(0) rotateY(0);
            border-color: #ff0055;
        }
        
        .active-state .cube-face {
            border-color: #ff0055;
            background: rgba(255, 0, 85, 0.2);
            box-shadow: 0 0 15px #ff0055;
        }

        #status {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00ffcc;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            pointer-events: none;
            font-size: 12px;
        }
    </style>
</head>
<body>

    <div id="status">Touch Cube to Enable Sensors</div>
    <div id="container"></div>

    <!-- The Cube Button -->
    <div class="scene-container" id="sensorBtn">
        <div class="cube">
            <div class="cube-face face-front">Touch</div>
            <div class="cube-face face-back">Me</div>
            <div class="cube-face face-right">X</div>
            <div class="cube-face face-left">Y</div>
            <div class="cube-face face-top">Z</div>
            <div class="cube-face face-bottom">G</div>
        </div>
    </div>

    <!-- Import Three.js via Module -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. SETUP THREE.JS SCENE ---
        const container = document.getElementById('container');
        const scene = new THREE.Scene();

        // Camera Setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.target = new THREE.Vector3(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        // --- 2. CREATE THE 360 SPHERE ---
        const geometry = new THREE.SphereGeometry(500, 60, 40);
        // Invert geometry so we view it from the inside
        geometry.scale(-1, 1, 1);

        // Load Texture
        const textureLoader = new THREE.TextureLoader();
        // Use CrossOrigin anonymous to handle external images
        textureLoader.setCrossOrigin('anonymous');
        
        const imageUrl = 'https://storage.noirlab.edu/media/archives/images/thumb300y/20220407_Pachon_P35mm_SOARG_L_Fulld1-CC.jpg';
        
        const texture = textureLoader.load(imageUrl);
        texture.colorSpace = THREE.SRGBColorSpace;

        const material = new THREE.MeshBasicMaterial({ map: texture });
        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // Variables for rotation
        let lon = 0, lat = 0;
        let phi = 0, theta = 0;
        let isUserInteracting = false;
        let onPointerDownPointerX = 0, onPointerDownPointerY = 0;
        let onPointerDownLon = 0, onPointerDownLat = 0;

        // Accelerometer Variables
        let useSensor = false;
        let accelX = 0, accelY = 0, accelZ = 0;

        // --- 3. INPUT HANDLERS (MOUSE/TOUCH) ---
        // This allows dragging the screen manually if sensors aren't used
        document.addEventListener('pointerdown', onPointerDown);
        document.addEventListener('pointermove', onPointerMove);
        document.addEventListener('pointerup', onPointerUp);
        document.addEventListener('wheel', onDocumentMouseWheel);

        function onPointerDown(event) {
            if (event.isPrimary === false) return;
            isUserInteracting = true;
            onPointerDownPointerX = event.clientX;
            onPointerDownPointerY = event.clientY;
            onPointerDownLon = lon;
            onPointerDownLat = lat;
        }

        function onPointerMove(event) {
            if (event.isPrimary === false || !isUserInteracting) return;
            lon = (onPointerDownPointerX - event.clientX) * 0.1 + onPointerDownLon;
            lat = (event.clientY - onPointerDownPointerY) * 0.1 + onPointerDownLat;
        }

        function onPointerUp() { isUserInteracting = false; }

        function onDocumentMouseWheel(event) {
            const fov = camera.fov + event.deltaY * 0.05;
            camera.fov = THREE.MathUtils.clamp(fov, 10, 75);
            camera.updateProjectionMatrix();
        }

        // --- 4. ACCELEROMETER LOGIC (THE REQUEST) ---
        const btn = document.getElementById('sensorBtn');
        const status = document.getElementById('status');

        btn.addEventListener('click', async () => {
            // iOS 13+ requires permission request
            if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                try {
                    const permissionState = await DeviceMotionEvent.requestPermission();
                    if (permissionState === 'granted') {
                        enableSensor();
                    } else {
                        status.innerText = "Permission Denied";
                    }
                } catch (e) {
                    console.error(e);
                    // Fallback for non-https or errors
                    enableSensor(); 
                }
            } else {
                // Non-iOS 13+ devices
                enableSensor();
            }
        });

        function enableSensor() {
            useSensor = !useSensor; // Toggle
            
            if (useSensor) {
                btn.classList.add('active-state');
                status.innerText = "Sensor Active: Tilt Phone to Steer";
                window.addEventListener('devicemotion', handleMotion, true);
            } else {
                btn.classList.remove('active-state');
                status.innerText = "Sensor Disabled";
                window.removeEventListener('devicemotion', handleMotion, true);
            }
        }

        function handleMotion(event) {
            // User requested ACCELEROMETER ONLY (no Gyro)
            // event.accelerationIncludingGravity gives x,y,z forces
            // When holding phone up: Y is roughly -9.8 (gravity)
            
            const acc = event.accelerationIncludingGravity;
            if(!acc) return;

            // Low pass filter to smooth out jitter
            const alpha = 0.1; 
            accelX = accelX + alpha * (acc.x - accelX);
            accelY = accelY + alpha * (acc.y - accelY);
            accelZ = accelZ + alpha * (acc.z - accelZ);
        }

        // --- 5. RENDER LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            update();
        }

        function update() {
            if (useSensor) {
                // ACCELEROMETER "JOYSTICK" LOGIC
                // Since Accel can't detect Yaw (compass direction), we use Tilt as a steering wheel.
                
                // 1. Tilt Left/Right (X-axis gravity) -> Adds to Longitude (Yaw)
                // Threshold of 1.0 to create a "dead zone" in the middle so it stops drifting
                if (Math.abs(accelX) > 1.0) {
                    // Multiply by small factor for speed
                    lon += accelX * 0.5; 
                }

                // 2. Tilt Forward/Back (Y/Z axis relationship) -> Sets Latitude (Pitch)
                // We calculate roughly how upright the phone is
                // When accelY is -9.8 (upright), lat should be 0.
                // When accelZ changes, we tilt up/down.
                
                // Simple mapping: Map Z axis (leaning back/forward) to Latitude
                // This is an approximation to fulfill "Do as you can max"
                lat = (accelZ - 2) * -5; 
            }

            // Clamp latitude to avoid flipping over
            lat = Math.max(-85, Math.min(85, lat));

            // Math to convert lat/lon to 3D vector for Camera
            phi = THREE.MathUtils.degToRad(90 - lat);
            theta = THREE.MathUtils.degToRad(lon);

            const x = 500 * Math.sin(phi) * Math.cos(theta);
            const y = 500 * Math.cos(phi);
            const z = 500 * Math.sin(phi) * Math.sin(theta);

            camera.lookAt(x, y, z);
            renderer.render(scene, camera);
        }

        // Handle Window Resize
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        animate();
    </script>
</body>
</html>
