<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Sphere Camera (No Gyro)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* Let clicks pass through to 3D view */
            display: flex; flex-direction: column; justify-content: space-between; align-items: center;
        }
        
        /* Viewfinder Reticle */
        .reticle {
            width: 250px; height: 250px;
            border: 2px dashed rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5); /* Dim outside area */
            pointer-events: none;
            z-index: 10;
        }

        /* Controls */
        .controls {
            margin-bottom: 30px;
            pointer-events: auto;
            display: flex; gap: 20px; z-index: 20;
        }
        
        button {
            padding: 15px 30px; font-size: 18px; border: none; border-radius: 30px;
            cursor: pointer; font-weight: bold; text-transform: uppercase;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3); transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }
        
        #btn-capture { background: #ff4757; color: white; }
        #btn-download { background: #2ed573; color: white; display: none; }
        
        /* Hidden Video Element for Stream */
        #webcam { display: none; }
        
        .status {
            margin-top: 20px; color: white; background: rgba(0,0,0,0.5);
            padding: 5px 15px; border-radius: 15px; font-size: 14px;
            pointer-events: auto;
        }
    </style>
</head>
<body>

    <!-- 3D Container -->
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <div class="status" id="status-text">Drag to look around. Align a gray face with the box.</div>
        <div class="reticle"></div>
        <div class="controls">
            <button id="btn-capture">Capture Segment</button>
            <button id="btn-download">Download Sphere</button>
        </div>
    </div>

    <!-- Hidden Video & Canvas for processing -->
    <video id="webcam" autoplay playsinline muted></video>
    <canvas id="temp-canvas" style="display:none;"></canvas>

    <!-- Import Three.js from CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let camera, scene, renderer, controls;
        let skyboxMesh;
        let materials = [];
        let capturedCount = 0;
        
        const video = document.getElementById('webcam');
        const tempCanvas = document.getElementById('temp-canvas');
        const tempCtx = tempCanvas.getContext('2d');
        const statusText = document.getElementById('status-text');

        // Initialize App
        init();
        startCamera();
        animate();

        function init() {
            const container = document.getElementById('canvas-container');

            // 1. Setup Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            // 2. Setup Camera (FOV 90 is good for face alignment)
            camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 0.1); // Slightly offset from center

            // 3. Setup Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // 4. Controls (Manual Alignment - Drag to rotate)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableZoom = false;
            controls.enablePan = false;
            controls.rotateSpeed = -0.5; // Invert drag to feel like "looking around" inside
            controls.enableDamping = true;

            // 5. Create the "Globe" (Skybox Cube)
            // We use a BoxGeometry because it has 6 flat faces which are perfect for "cards"
            // that don't distort capture images like a sphere would.
            const geometry = new THREE.BoxGeometry(10, 10, 10);
            
            // Create 6 materials (one for each face)
            // Order: Right, Left, Top, Bottom, Front, Back
            for (let i = 0; i < 6; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = 512; canvas.height = 512;
                const ctx = canvas.getContext('2d');
                
                // Draw placeholder graphics
                ctx.fillStyle = '#444'; 
                ctx.fillRect(0,0,512,512);
                ctx.strokeStyle = '#666'; 
                ctx.lineWidth = 10; 
                ctx.strokeRect(0,0,512,512);
                ctx.fillStyle = '#fff'; 
                ctx.font = '40px Arial'; 
                ctx.textAlign = 'center';
                ctx.fillText(`Face ${i+1}`, 256, 256);

                const tex = new THREE.CanvasTexture(canvas);
                materials.push(new THREE.MeshBasicMaterial({ map: tex, side: THREE.BackSide }));
            }

            skyboxMesh = new THREE.Mesh(geometry, materials);
            // Invert scale to put normals on inside (so we see it from inside)
            skyboxMesh.scale.set(-1, 1, 1); 
            scene.add(skyboxMesh);

            // 6. Raycaster for selection
            window.addEventListener('resize', onWindowResize);
            document.getElementById('btn-capture').addEventListener('click', onCapture);
            document.getElementById('btn-download').addEventListener('click', downloadEquirectangular);
        }

        async function startCamera() {
            try {
                // Request square aspect ratio if possible, otherwise crop later
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment', aspectRatio: 1 } 
                });
                video.srcObject = stream;
            } catch (err) {
                alert("Camera access denied or error: " + err);
            }
        }

        function onCapture() {
            if (video.readyState !== video.HAVE_ENOUGH_DATA) return;

            // 1. Find which face we are looking at
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera); // Ray from center of screen
            
            // Note: We raycast against the box. Since scale is -1, we need to be careful with direction
            // But basic intersection works.
            const intersects = raycaster.intersectObject(skyboxMesh);

            if (intersects.length > 0) {
                const faceIndex = intersects[0].face.materialIndex;
                const material = materials[faceIndex];

                // 2. Draw Webcam frame to texture
                const size = 1024; // High res texture
                tempCanvas.width = size;
                tempCanvas.height = size;
                
                // Crop center square from video
                const vidH = video.videoHeight;
                const vidW = video.videoWidth;
                const minDim = Math.min(vidW, vidH);
                const sx = (vidW - minDim) / 2;
                const sy = (vidH - minDim) / 2;

                // Flip horizontally because we are inside a mirrored cube (scale.x = -1)
                tempCtx.translate(size, 0);
                tempCtx.scale(-1, 1);
                
                tempCtx.drawImage(video, sx, sy, minDim, minDim, 0, 0, size, size);

                // 3. Update Material
                const newTex = new THREE.CanvasTexture(tempCanvas);
                newTex.colorSpace = THREE.SRGBColorSpace; // Correct color profile
                
                // Dispose old texture to free memory
                material.map.dispose();
                material.map = newTex;
                material.needsUpdate = true;

                // 4. Feedback
                flashScreen();
                statusText.innerText = "Captured! Rotate to next face.";
                
                // Check if simple count logic (rough estimate)
                if (!material.userData.captured) {
                    material.userData.captured = true;
                    capturedCount++;
                }

                if (capturedCount >= 6) {
                    document.getElementById('btn-download').style.display = 'block';
                    statusText.innerText = "All segments filled! Ready to download.";
                }
            }
        }

        // Generate Equirectangular Image using a Custom Shader
        function downloadEquirectangular() {
            const width = 4096;
            const height = 2048;

            // Create a CubeTexture from our 6 existing materials
            // We have to extract the images from the materials
            const images = materials.map(m => m.map.image);
            
            // Standard order for CubeTexture is: px, nx, py, ny, pz, nz
            // Our materials array corresponds to geometry faces. 
            // BoxGeometry face order depends, but usually: Right, Left, Top, Bottom, Front, Back
            // We need to map our materials array to this order correctly.
            // Let's rely on Three.js standard box mapping.
            
            // To ensure 100% seamless export, we will render the SCENE itself to a WebGLRenderTarget
            // instead of manually stitching images. This handles rotations perfectly.
            
            const exportScene = new THREE.Scene();
            // Duplicate the mesh for export
            const exportMesh = new THREE.Mesh(skyboxMesh.geometry.clone(), materials);
            exportMesh.scale.set(-1, 1, 1);
            exportMesh.rotation.copy(skyboxMesh.rotation); // Keep orientation? No, reset for standard export
            exportMesh.rotation.set(0,0,0);
            exportScene.add(exportMesh);

            // Create a CubeCamera to snapshot the box from the inside
            const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(2048);
            const cubeCamera = new THREE.CubeCamera(0.1, 1000, cubeRenderTarget);
            exportScene.add(cubeCamera);
            
            // Render the box into the CubeCamera
            cubeCamera.update(renderer, exportScene);

            // Now, use a shader to convert that CubeRenderTarget to Equirectangular
            const equiMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    map: { value: cubeRenderTarget.texture },
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = vec4( position, 1.0 );
                    }
                `,
                fragmentShader: `
                    uniform samplerCube map;
                    varying vec2 vUv;
                    const float PI = 3.14159265359;
                    const float TWO_PI = 6.28318530718;
                    void main() {
                        vec2 uv = vUv;
                        float longitude = uv.x * TWO_PI - PI;
                        float latitude = uv.y * PI - PI / 2.0;
                        vec3 dir = vec3(
                            -cos(latitude) * sin(longitude), // Negate X for correct mapping
                            sin(latitude),
                            -cos(latitude) * cos(longitude)  // Negate Z
                        );
                        gl_FragColor = textureCube(map, normalize(dir));
                    }
                `,
                side: THREE.DoubleSide
            });

            const exportPlane = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), equiMaterial);
            const postScene = new THREE.Scene();
            postScene.add(exportPlane);
            const postCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

            // Render to canvas
            renderer.setSize(width, height);
            renderer.render(postScene, postCamera);

            // Save
            const dataURL = renderer.domElement.toDataURL('image/jpeg', 0.9);
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = '3d-sphere-photo.jpg';
            link.click();

            // Reset renderer
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function flashScreen() {
            const div = document.createElement('div');
            div.style.position = 'fixed'; div.style.top = 0; div.style.left = 0;
            div.style.width = '100%'; div.style.height = '100%';
            div.style.background = 'white'; div.style.opacity = 0.8;
            div.style.transition = 'opacity 0.2s'; div.style.pointerEvents = 'none';
            document.body.appendChild(div);
            setTimeout(() => div.style.opacity = 0, 50);
            setTimeout(() => div.remove(), 250);
        }
    </script>
</body>
</html>
