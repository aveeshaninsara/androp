<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Grid 360 Controller</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
        }

        /* FULLSCREEN CANVAS */
        #container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            background: radial-gradient(circle at center, #111 0%, #000 100%);
        }

        /* UI OVERLAY */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* STATUS BAR */
        #status {
            background: rgba(0, 255, 0, 0.1);
            color: #0f0;
            padding: 15px;
            text-align: center;
            font-size: 14px;
            border-bottom: 1px solid #0f0;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 5px #0f0;
            pointer-events: auto;
        }

        /* BOTTOM CONTROLS */
        .controls {
            padding-bottom: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }

        /* CUBE BUTTON */
        .scene-container {
            width: 80px;
            height: 80px;
            perspective: 800px;
            pointer-events: auto; /* Enable clicks */
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .cube {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            animation: idleSpin 10s infinite linear;
        }

        @keyframes idleSpin {
            0% { transform: rotateX(-20deg) rotateY(0deg); }
            100% { transform: rotateX(-20deg) rotateY(360deg); }
        }

        .cube-face {
            position: absolute;
            width: 80px;
            height: 80px;
            border: 2px solid #0f0;
            background: rgba(0, 20, 0, 0.85);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.4) inset;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #0f0;
            font-weight: bold;
            user-select: none;
            backface-visibility: hidden;
        }

        /* POSITIONS */
        .face-front  { transform: rotateY(  0deg) translateZ(40px); }
        .face-right  { transform: rotateY( 90deg) translateZ(40px); }
        .face-back   { transform: rotateY(180deg) translateZ(40px); }
        .face-left   { transform: rotateY(-90deg) translateZ(40px); }
        .face-top    { transform: rotateX( 90deg) translateZ(40px); }
        .face-bottom { transform: rotateX(-90deg) translateZ(40px); }

        /* ACTIVE STATE (ON) */
        .active-state .cube {
            animation: none;
        }
        .active-state .cube-face {
            border-color: #ff0055;
            color: #ff0055;
            background: rgba(40, 0, 10, 0.9);
            box-shadow: 0 0 20px #ff0055;
        }
    </style>
</head>
<body>

    <div id="container"></div>

    <div id="ui-layer">
        <div id="status">TAP CUBE TO ACTIVATE SENSOR</div>
        
        <div class="controls">
            <div class="scene-container" id="toggleBtn">
                <div class="cube" id="cubeVis">
                    <div class="cube-face face-front">OFF</div>
                    <div class="cube-face face-back">ON</div>
                    <div class="cube-face face-right">►</div>
                    <div class="cube-face face-left">◄</div>
                    <div class="cube-face face-top">▲</div>
                    <div class="cube-face face-bottom">▼</div>
                </div>
            </div>
        </div>
    </div>

    <!-- THREE.JS -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. SETUP SCENE ---
        const container = document.getElementById('container');
        const statusEl = document.getElementById('status');
        
        const scene = new THREE.Scene();
        // Add some fog for depth
        scene.fog = new THREE.FogExp2(0x000000, 0.0015);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // --- 2. CREATE THE GRID (REPLACING THE IMAGE) ---
        // We use a large sphere with wireframe to create a 360 grid effect
        const geometry = new THREE.SphereGeometry(600, 40, 24);
        geometry.scale(-1, 1, 1); // Invert so we are inside

        const material = new THREE.MeshBasicMaterial({
            color: 0x00ff00,    // Matrix Green
            wireframe: true,
            transparent: true,
            opacity: 0.3
        });

        const gridMesh = new THREE.Mesh(geometry, material);
        scene.add(gridMesh);

        // Add a secondary grid for visual complexity
        const subGeo = new THREE.SphereGeometry(550, 80, 48);
        subGeo.scale(-1, 1, 1);
        const subMat = new THREE.MeshBasicMaterial({
            color: 0x004400,
            wireframe: true,
            transparent: true,
            opacity: 0.1
        });
        scene.add(new THREE.Mesh(subGeo, subMat));


        // --- 3. MOVEMENT VARIABLES ---
        let lon = 0, lat = 0; // Camera angles
        let phi = 0, theta = 0;
        
        // Manual Drag
        let isUserInteracting = false;
        let onPointerDownPointerX = 0, onPointerDownPointerY = 0;
        let onPointerDownLon = 0, onPointerDownLat = 0;

        // Sensor State
        let isSensorActive = false;
        
        // Calibration (The "Zero" Point)
        let calibX = 0, calibY = 0;
        let currentX = 0, currentY = 0;

        // --- 4. TOUCH INTERACTION (DRAG) ---
        document.addEventListener('pointerdown', (e) => {
            if (e.target.closest('#toggleBtn')) return; // Ignore cube clicks
            isUserInteracting = true;
            onPointerDownPointerX = e.clientX;
            onPointerDownPointerY = e.clientY;
            onPointerDownLon = lon;
            onPointerDownLat = lat;
        });

        document.addEventListener('pointermove', (e) => {
            if (!isUserInteracting) return;
            lon = (onPointerDownPointerX - e.clientX) * 0.1 + onPointerDownLon;
            lat = (e.clientY - onPointerDownPointerY) * 0.1 + onPointerDownLat;
        });

        document.addEventListener('pointerup', () => isUserInteracting = false);


        // --- 5. SENSOR LOGIC (TOGGLE) ---
        const toggleBtn = document.getElementById('toggleBtn');
        const cubeVis = document.getElementById('cubeVis');

        toggleBtn.addEventListener('click', async () => {
            
            // Check iOS Permissions on first click
            if (!isSensorActive && typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                try {
                    const response = await DeviceMotionEvent.requestPermission();
                    if (response !== 'granted') {
                        statusEl.innerText = "PERMISSION DENIED";
                        return;
                    }
                } catch (e) {
                    console.error(e);
                }
            }

            // TOGGLE STATE
            isSensorActive = !isSensorActive;

            if (isSensorActive) {
                // ACTIVATED
                toggleBtn.classList.add('active-state');
                statusEl.innerHTML = "SENSOR ON <br> <span style='font-size:10px'>Hold steady to calibrate...</span>";
                
                // Reset calibration triggers
                calibX = null; 
                
                window.addEventListener('devicemotion', handleMotion, true);

            } else {
                // DEACTIVATED
                toggleBtn.classList.remove('active-state');
                statusEl.innerText = "SENSOR OFF (Tap Cube)";
                
                window.removeEventListener('devicemotion', handleMotion, true);
                
                // Reset Cube Visual
                cubeVis.style.transform = '';
            }
        });

        function handleMotion(event) {
            const acc = event.accelerationIncludingGravity;
            if (!acc) return;

            // Low Pass Filter (Smooths out jitter)
            const alpha = 0.15;

            // Capture initial state as "Zero" if newly activated
            if (calibX === null) {
                calibX = acc.x;
                calibY = acc.y;
                currentX = acc.x;
                currentY = acc.y;
                statusEl.innerText = "SENSOR ACTIVE - TILT TO MOVE";
                return;
            }

            // Apply smoothing
            currentX += alpha * (acc.x - currentX);
            currentY += alpha * (acc.y - currentY);

            // Calculate Difference from Calibration Point
            const deltaX = currentX - calibX; // Left/Right Tilt
            const deltaY = currentY - calibY; // Up/Down Tilt

            // VISUALIZE ON CUBE
            cubeVis.style.transform = `rotateX(${-deltaY * 15}deg) rotateY(${deltaX * 15}deg)`;

            // APPLY TO CAMERA
            const deadzone = 0.5; // Minimum tilt required to move
            const speed = 1.2;

            // Yaw (Left/Right)
            if (Math.abs(deltaX) > deadzone) {
                lon += deltaX * speed;
            }

            // Pitch (Up/Down)
            // LOGIC: "When device moves UP, move grid DOWN"
            // If I tilt device UP (Top Back), deltaY usually changes.
            // Standard Camera: Look UP -> Lat INCREASES -> Grid moves DOWN visually.
            // We subtract deltaY (depending on device orientation standard, Y is usually negative when upright).
            // We will use standard flight control: Pull Back (Tilt Up) -> Look Up.
            
            if (Math.abs(deltaY) > deadzone) {
                // 'lat' controls Looking Up/Down.
                // Subtracting deltaY usually maps Tilt Back -> Look Up
                lat -= deltaY * speed; 
            }
        }

        // --- 6. RENDER LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // Calculate 3D Point
            lat = Math.max(-85, Math.min(85, lat)); // Prevent full flip
            phi = THREE.MathUtils.degToRad(90 - lat);
            theta = THREE.MathUtils.degToRad(lon);

            const x = 500 * Math.sin(phi) * Math.cos(theta);
            const y = 500 * Math.cos(phi);
            const z = 500 * Math.sin(phi) * Math.sin(theta);

            camera.lookAt(x, y, z);

            // Rotate grid slightly for effect
            if (!isSensorActive && !isUserInteracting) {
                lon += 0.05; // Auto rotate very slowly if idle
            }

            renderer.render(scene, camera);
        }

        // Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
