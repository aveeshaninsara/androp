<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>No-Gyro Camera 360 (Back Camera)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
  html, body {
    margin: 0;
    overflow: hidden;
    background: black;
  }
  video, canvas#cv {
    display: none; /* FULLY HIDDEN */
  }
</style>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.155/build/three.min.js"></script>

<!-- OpenCV.js -->
<script async src="https://docs.opencv.org/4.9.0/opencv.js"></script>
</head>

<body>

<video id="video" autoplay playsinline></video>
<canvas id="cv"></canvas>

<script>
/* =========================
   THREE.JS SCENE
========================= */

const scene = new THREE.Scene()

const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
)

const renderer = new THREE.WebGLRenderer({ antialias: true })
renderer.setSize(window.innerWidth, window.innerHeight)
document.body.appendChild(renderer.domElement)

// 360 sphere
const geometry = new THREE.SphereGeometry(500, 64, 48)
geometry.scale(-1, 1, 1)

// IMPORTANT: use crossOrigin-safe loading
const texture = new THREE.TextureLoader()
texture.setCrossOrigin("anonymous")

const pano = texture.load(
  "https://storage.noirlab.edu/media/archives/images/large/20220407_Pachon_P35mm_SOARG_L_Fulld1-CC.jpg"
)

const material = new THREE.MeshBasicMaterial({ map: pano })
scene.add(new THREE.Mesh(geometry, material))

camera.rotation.order = "YXZ"

/* =========================
   BACK CAMERA STREAM
========================= */

const video = document.getElementById("video")

navigator.mediaDevices.getUserMedia({
  video: { facingMode: { exact: "environment" } },
  audio: false
}).then(stream => {
  video.srcObject = stream
}).catch(() => {
  // fallback
  navigator.mediaDevices.getUserMedia({ video: true })
    .then(stream => video.srcObject = stream)
})

/* =========================
   OPTICAL FLOW TRACKING
========================= */

let yaw = 0
let pitch = 0

let lastGray = null
let ready = false

const cvCanvas = document.getElementById("cv")
const ctx = cvCanvas.getContext("2d")

function processFrame() {
  if (!ready || video.videoWidth === 0) return

  cvCanvas.width = 320
  cvCanvas.height = 240

  ctx.drawImage(video, 0, 0, 320, 240)

  const src = cv.imread(cvCanvas)
  const gray = new cv.Mat()
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY)

  if (lastGray) {
    const flow = new cv.Mat()
    cv.calcOpticalFlowFarneback(
      lastGray, gray, flow,
      0.5, 3, 15, 3, 5, 1.2, 0
    )

    let dx = 0, dy = 0, count = 0

    for (let y = 0; y < flow.rows; y += 10) {
      for (let x = 0; x < flow.cols; x += 10) {
        const f = flow.floatAt(y, x * 2)
        dx += f
        dy += flow.floatAt(y, x * 2 + 1)
        count++
      }
    }

    dx /= count
    dy /= count

    yaw   -= dx * 0.04
    pitch -= dy * 0.04

    pitch = Math.max(-1.3, Math.min(1.3, pitch))

    flow.delete()
    lastGray.delete()
  }

  lastGray = gray
  src.delete()
}

/* =========================
   MAIN LOOP
========================= */

function animate() {
  requestAnimationFrame(animate)

  processFrame()

  camera.rotation.y += (yaw - camera.rotation.y) * 0.08
  camera.rotation.x += (pitch - camera.rotation.x) * 0.08

  renderer.render(scene, camera)
}

cv['onRuntimeInitialized'] = () => {
  ready = true
  animate()
}

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight
  camera.updateProjectionMatrix()
  renderer.setSize(window.innerWidth, window.innerHeight)
})
</script>

</body>
</html>
